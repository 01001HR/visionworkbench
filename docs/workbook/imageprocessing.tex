\chapter{Image Processing}

Now that we've covered all the basics of how to manipulate images, 
it's time to move on to some more interesting image processing 
tasks.  We begin with an introduction to image filtering, followed 
by a discussion of image math.  We then take a brief detour to 
introduce the Vision Workbench's \verb#Vector# and \verb#Matrix# 
classes before describing image transformation and warping.

By the end of this chapter you will have encoutered all of the core
building blocks that comprise the heart of the Vision Workbench.
There are a number of directions that you can go from here, depending
on what you are hoping to accomplish.  We conclude this chapter with
an overview of the many more specialized features of the Vision
Workbench and a discussion of where to look (in this book and
elsewhere) in order to learn more about them.

\section{Image Filtering}

Image filtering has traditionally been the bread and butter of image
processing software packages.  The Vision Workbench includes a number
of functions to perform the most common filtering operations.  We will
first describe the special-purpose filters, and then we will discuss
the more general convolution-based linear filtering functions.  All of
the filter functions discussed in this section are defined in the
header file \verb#<vw/Filter.h>#.  We will not discuss
frequency-domain filtering in this chapter; that is covered later in
Section~\ref{sec:advanced.frequency}.

\begin{table}[t]\begin{centering}
\begin{tabular}{|c|l|l|} \hline
Function & Description \\ \hline \hline
\verb#gaussian_filter(im,...)# & Apply a Gaussian smoothing filter to an image \\ \hline
\verb#derivative_filter(im,...)# & Apply a discrete differentiation filter to an image \\ \hline
\verb#laplacian_filter(im,...)# & Apply a discrete Laplacian filter to an image \\ \hline
\verb#convolution_filter(im,...)# & Apply a general 2D convolution filter to an image \\ \hline
\verb#separable_convolution_filter(im,...)# & Apply a separable convolution filter to an image \\ \hline
\end{tabular}
\caption{The Vision Workbench image filtering functions, defined in {\tt <vw/Filter.h>}.}
\label{tbl:image-filters}
\end{centering}\end{table}

\subsection{The Special-Purpose Filters}

At the moment only three special-purpose filters are fully supported.
The first is a Gaussian smoothing or blurring filter, which convolves
the image with a discrete Gaussian kernel that has a user-specified
standard deviation (a.k.a. ``sigma'') and user-specified size in each
axis. In order for the filter to accurately approximate a Gaussian,
the size of the kernel should be at least a few times the standard
deviation.  However, unnecessary computation is performed if the size
is much larger than that.  You can omit the size arguments, in which
case the function will pick a kernel size based on your standard
deviation that is reasonable for most applications.  In the most
common case the two standard deviations are equal, in which case you
need only specify a single value for sigma.
\begin{verbatim}
  result = gaussian_filter( image, sigma );
  result = gaussian_filter( image, xsigma, ysigma );
  result = gaussian_filter( image, xsigma, ysigma, xsize, ysize );
\end{verbatim}
In these examples, the \verb#sigma# arguments are generally
floating-point whereas the \verb#size# variables are integers.

The next filter is the derivative filter, which performs a 
discrete spatial differentiation of your image.  Here again, you 
can specify the order of differentiation in the two axes as well 
as the filter kernel size.
\begin{verbatim}
  result = derivative_filter( image, xderiv, yderiv );
  result = derivative_filter( image, xderiv, yderiv, xsize, ysize );
\end{verbatim}
There is a minimum filter size below which it is not possible compute
any given derivative, and these functions will throw an exception if
you try.  For the most part it is a good idea to just let the Vision
Workbench pick the kernel size.

The final special-purpose filter is the Laplacian filter, which 
performs a discrete approximation to the Laplacian operation
$\nabla^2=\frac{d^2}{dx^2}+\frac{d^2}{dy^2}$.
\begin{verbatim}
  result = laplacian_filter( image );
\end{verbatim}
This filter does not take any special parameters.  Note that if you 
are accustomed to using a ``larger'' derivative or Laplacian filter 
to reduce the effect of noise, you are probably better off applying 
a smoothing operation (e.g. via \verb#gauusian_filter()#) first.

\subsection{Edge Extension Modes}

\begin{table}[t]\begin{centering}
\begin{tabular}{|c|l|l|} \hline
Type & Description \\ \hline \hline
\verb#ConstantEdgeExtend# & Assume constant (i.e. nearest-neighbor) edge extension \\ \hline
\verb#ZeroEdgeExtend# & Assume zero-value edge extension \\ \hline
\end{tabular}
\caption{The edge extension modes.}
\label{tbl:edge-extension-modes}
\end{centering}\end{table}

To filter the regions near the edges of an image properly, 
filters like these need to make some sort of assumption 
about the contents of the source image {\it beyond} the 
image boundaries.  This is generally referred to as ``edge 
extension''.  The default assumption made by the filters 
discussed in this section is that in each direction the 
image is extended with a constant value equal to the value 
of the nearest edge pixel.  However, you can specify an 
alternative edge extension mode if you wich, by passing 
an extra argument to the filters.  The C++ type of the 
argument determines the edge extension mode used.  
\begin{verbatim}
  result = gaussian_filter( image, 3.0, ConstantEdgeExtend() );
  result = gaussian_filter( image, 3.0, ZeroEdgeExtend() );
\end{verbatim}
Both of these examples filter the source image using a 
standard deviation of three pixels and an automatically-chosen 
kernel size.  However, the first explicitly requests the 
default edge extension behavior, while the second requests 
that the source image be assumed to be zero outside the 
image boundaries.

Notice the ``extra'' set of parentheses after the names 
of the edge extension modes.  Remember that those names are 
C++ {\it types}, and you can only pass an {\it object} as an 
argument to a function.  Those parentheses invoke the 
edge extension type's constructor, returning a dummy 
object that you pass as the final argument to the filtering 
function.  If you find this confusing, don't worry too much 
about it right now.  Just keep in mind that when you're 
using a type as an argument to a function to change it's 
behavior you need the extra parentheses.  The types that 
are currently supported as edge extension modes are listed 
in Table~\ref{tbl:edge-extension-modes}.

\subsection{General Convolution Filtering}

Most of the filters used in image processing are convolution filters,
which express each output pixel as a fixed weighted sum of neighboring
input pixels.  An image convolution filter is usually described by a
rectangular array of weights called the {\it kernel}.  The easiest way
to think about an image kernel is as the result that you would desire 
from the filter if the input image had the value $1$ at the origin and
zero everywhere else.  (This is also known as the ``impulse response''
of the filter.)  For example, a first-order derivative filter in the
$x$ direction might have the kernel
$[\begin{array}{ccc} 1 & 0 & -1 \end{array}]$.
In this case we also need to know that the middle number of the kernel 
(the zero in this case) is the kernel's origin.

In the Vision Workbench, convolution kernels---which as we've said are 
nothing more than rectangular arrays of numbers---are represented by 
images.  The pixel type for a kernel should generally be a scalar type 
such as \verb#float#.  Once you've put the kernel that you'd like into 
an image it is straightforward to use it to filter another image.
\begin{verbatim}
  ImageView<float> kernel;
  /* set up your kernel here */
  result = convolution_filter( image, kernel );
\end{verbatim}
In this case the Vision Workbench assumes that the center pixel of the
kernel is the kernels's origin.  If this is not what you want then you
can specify the coordinates of the kernel's origin explicitly instead.
\begin{verbatim}
  result = convolution_filter( image, kernel, ox, oy );
\end{verbatim}
In either case you can also optionally specify an edge extension mode, 
just like you could for the special-purpose filters.

Convolution filtering can be computationally expensive if the kernel
is large.  Fortunately, many useful kernels have a special form that
makes it possible to improve the performance considerably.  These are
called {\it separable} kernels, and are themselves the result of
convolving a single-column image with a single-row image.  In other
words, the kernel $K$ must satisfy $K(x,y)=K_x(x)K_y(y)$ for some
functions $K_x$ and $K_y$.  The Gaussian and derivative filters
are both of this form, for example, though the Laplacian filter is
not.

The Vision Workbench provides special support for efficient 
convolution filtering with saseparable kernels.  You must supply the 
{\it separated} kernel, i.e. two one-dimensional kernels.
\begin{verbatim}
  result = separable_convolution_filter( image, xkernel, ykernel );
  result = separable_convolution_filter( image, xkernel, ykernel, ox, oy );
\end{verbatim}
As in the general 2D convolution case, the origin of the kernel is 
assumed to be in the middle if you do not specify otherwise and in 
either case you can add an optional argument specifying the edge 
extension mode.  You can still supply the one-dimensional kernels as 
images, just as you did in the general 2D convolution case, but here 
you can also provide them in another STL-compliant container, such 
as a \verb#std::vector# or (as we shall introduce later this chapter) 
a \verb#vw::Vector#.  If you do chose to represent the kernels as 
images, remember that each should have one of the dimensions set to 1.

\section{Doing Math with Images}

In image processing it is often desirable to perform some mathematical 
operation on every pixel of an image, or to corresponding pixels from 
several images.  For example gamma correction involves applying a 
mathematical function to each pixel, and background subtraction involves
subtracting the corresponding pixels from two images.  In the Vision 
Workbench, these operaations and others like them fall under the rubric 
of ``image math'', and the functions to support them are defined in the 
header \verb#<vw/ImageMath.h>#.

\subsection{Image Operators}

In most cases writing code to perform image math is trivial.  The 
mathematical expressions that you would normally write for individual 
pixels work just as well for whole images of pixels.  For example, 
consider the background subtraction problem mentioned above.
\begin{verbatim}
  result_image = input_image - background_image;
\end{verbatim}
That's all there is to it.  Setting up an IIR lowpass filter to 
estimate the background image is just as easy.
\begin{verbatim}
  background_image = alpha*input_image + (1-alpha)*background_image;
\end{verbatim}
(Here we're assuming that \verb#alpha# is a small positive
floating-point number.)  The important point is that there is no need 
for you to write a loop that performs an operation like this on each 
pixel.  Just write the mathematic expression, replacing pixels with 
images, and you're all set.

\begin{table}[t]\begin{centering}
\begin{tabular}{|c|c|c|c|} \hline
Per-pixel Sum & Per-pixel Difference & Per-pixel Product & Per-pixel Quotient \\ \hline \hline
\verb#image + image#  & \verb#image - image#  & \verb#image * image#  & \verb#image / image#  \\ \hline
\verb#image += image# & \verb#image -= image# & \verb#image *= image# & \verb#image /= image# \\ \hline
\verb#image + value#  & \verb#image - value#  & \verb#image * value#  & \verb#image / value#  \\ \hline
\verb#image += value# & \verb#image -= value# & \verb#image *= value# & \verb#image /= value# \\ \hline
\verb#value + image#  & \verb#value - image#  & \verb#value * image#  & \verb#value / image#  \\ \hline
\end{tabular}
\caption{The Vision Workbench image operators, defined in {\tt <vw/ImageOperators.h>} (which 
is in turn included automatically by {\tt <vw/ImageMath.h>}).}
\label{tbl:image-operators}
\end{centering}\end{table}

This works, of course, because the Vision Workbench has overloaded the
standard C++ mathematical operators to work on images too.  These
operators are listed in Table~\ref{tbl:image-operators}.  Operation
with scalars is treated identically to per-pixel operation with
constant-value images.  In order to simplify division with large
images, the image division operators have been designed so that
division by zero returns zero instead of throwing an exception.

There is one important issue to bear in mind when using image
operators: the underlying per-pixel operations must themselves be
meaningful.  For example, multiplying an image whose pixel type is
\verb#PixelGray# by an image whose pixel type is \verb#PixelRGB# is
not wel-defined, and attempting to do so will result in a compiler
error.  The Vision Workbench will not automatically ``promote'' the
grayscale image to RGB.

This raises the question of what happens when you multiply two images
both of whose pixel type is, for example, \verb#PixelRGB#.  What does
it mean to multiply two RGB colors?  Multiplication is defined defined
for numbers, not colors.  The answer is that in this situation the
Vision Workbench will actually perform the mathematical operation on a
per-{\it channel} basis rather than just a per-pixel basis.

A good rule of thumb when working with image operators is to restrict
yourself to operating on images of the same type, or combinations of
images of one type and images of scalars.  As long as you obey this
rule you should find that the image operators always do what you
expect.

\subsection{Mathematical Functions}

\begin{table}[t]\begin{centering}
\renewcommand\arraystretch{1.2}
\begin{tabular}{|c|c|c|c|} \hline
Function & Description & Function & Description \\ \hline \hline
\verb#sin# & Sine, $\sin x$ & \verb#asin# & Inverse sine, $\sin^{-1} x$ \\ \hline
\verb#cos# & Cosine, $\cos x$ & \verb#acos# & Inverse cosine, $\cos^{-1} x$ \\ \hline
\verb#tan# & Tangent, $\tan x$ & \verb#atan# & Inverse tangent, $\tan^{-1} x$ \\ \hline
\verb#atan2# & \multicolumn{3}{|l|}{Two-argument form of inverse tangent, $\tan^{-1}\!\!\ ^x\!/\!_y$ } \\ \hline
\verb#sinh# & Hyperbolic sine, $\sinh x$ & \verb#cosh# & Hyperbolic cosine, $\cosh x$ \\ \hline
\verb#tanh# & Hyperbolic tangent, $\tanh x$ & \verb#exp# & Exponential, $e^x$ \\ \hline
\verb#log# & Natural logarithm, $\ln x$ & \verb#log10# & Base-10 logarithm, $\log_{10} x$ \\ \hline
\verb#ceil# & Ceiling function, $\lceil x \rceil$ & \verb#floor# & Floor function, $\lfloor x \rfloor$ \\ \hline
\verb#sqrt# & Square root, $\sqrt{x}$ & \verb#pow# & Power function, $x^y$ \\ \hline
\hline
\verb#asinh# & Inverse hyperbolic sine, $\sinh^{-1} x$ & \verb#acosh# & Inverse hyperbolic cosine, $\cosh^{-1} x$ \\ \hline
\verb#atanh# & Inverse hyberbolic tangent, $\tanh^{-1} x$ & \verb#cbrt# & Cube root, $\sqrt[3]{x}$ \\ \hline
\verb#exp2# & Base-2 exponential, $2^x$ & \verb#expm1# & Exponential minus 1, $e^x-1$ \\ \hline
\verb#log2# & Base-2 logarithm, $\log_2 x$ & \verb#log1p# & Lograithm of one-plus, $\ln (1+x)$ \\ \hline
\verb#tgamma# & Gamma function, $\Gamma(x)$ & \verb#lgamma# & Log of Gamma function, $\ln |\Gamma(x)|$ \\ \hline
\verb#hypot# & Hypotenuse, $\sqrt{x^2+y^2}$ & \verb#copysign# & Sign-copying function \\ \hline
\verb#round# & Rounding function & \verb#trunc# & Floating-point truncation \\ \hline
\verb#fdim# & Positive difference, $\max(x-y,0)$ & & \\ \hline
\end{tabular}
\caption{The Vision Workbench image math functions, as defined in {\tt <vw/ImageMath.h>}.
The functions in the bottom section are not available under the Windows operating system.}
\label{tbl:math-functions}
\end{centering}\end{table}

Of course, C++ provides a range of mathematical functions, too, such
as exponentials and logarithms, trigonometric functions, and so forth.
The Vision Workbench extends these functions to operate on images as
well.  The supported functions are listed in
Table~\ref{tbl:math-functions}.  Note that these image functions are
built on top of the standard C++ functions that operate on regular
numbers.  Therefore, the Vision Workbench only supports those
functions that are provided by your platform.  In particular, the
bottom half of Table~\ref{tbl:math-functions} lists functions that are
{\it not} currently available under the Microsoft Windows operating
system.

You can use these functions just like you use the mathematical 
operators: write the same expression that you would write for 
individual pixels, but substitute whole images instead.
\begin{verbatim}
  result_image = pow( input_image, gamma );
\end{verbatim}
This example demonstrates how to use the \verb#pow()# function to 
gamma-correct an image.  (Here we are imagining that the variable 
\verb#gamma# is a floating-point number representing the desired 
gamma correction factor.)  This example also demonstrates the fact 
that either of the arguments of a two-argument mathematical function 
can be a single value instead of an image.  Just as with the operators, 
this is treated the just like a constant-value image.

Note that unlike the normal mathematical functions that C++ inherited
from C, it is not necessary (or correct) to use a different function
name when you are working with \verb#float# image data than you would
use to work with \verb#double# image data.  The function names listed
in Table~\ref{tbl:math-functions} are correct for image math in all
cases.  Those in turn use the proper underlying mathematical functions
as apppropriate---for example, \verb#sin()# invokes \verb#sinf()# on 
each pixel if it is applied to a \verb#float#-based image.

\section{Vectors and Matrices}

Before introducing the next image processing topic, image transformation 
and warping, we must first take a brief detour to introduce the Vision 
Workbench vector and matrix classes.  We will assume in this chapter 
that you have a good familiarity with the underlying mathemtatical 
entities that these classes represent.  Note that our mathematical usage 
of the word ``vector'' here is somewhat different from the C++ standard 
library's use of the word to mean a dynamically-resizable array.

\subsection{Vectors and Vector Operations}

The Vision workbench vector class is called, appropriately enough, 
\verb#Vector#.  Like \verb#ImageView#, \verb#Vector# is a template 
class whose first template parameter is required and specifies the 
underlying numeric type.  However, while the dimensions of an image 
are always specified at run-time via the image's constructor or the 
\verb#set_size()# method, \verb#Vector# comes in two variants.  The 
first form behaves in just the same way, but the second form has a 
fixed size that is specified at compile time.  This eliminates the 
need for frequent dynamic allocation when working with vectors in 
the common case when the vector dimension is known.

Declaring either type of vector is straightforward:
\begin{verbatim}
  Vector<float> vector1(3);
  Vector<float,3> vector2;
\end{verbatim}
Both of those statements declare three-dimensional vectors of 
floating-point numbers.  In the first case the vector is allocated 
dynamically on the heap and the size could have been chosen at 
run-time.  In the second case the vector is allocated statically 
on the stack, but the dimension can {\it not} vary at run time.
The first form is generally useful when, say, reading a large 
vector of data in from a file, while the second form is more 
useful when performing geometric computations.

The second, fixed-dimension form also has special constructors that
you can use to initialize the vector contents:
\begin{verbatim}
  Vector<float,3> vector2(1,2,3);
\end{verbatim}
These constructors are available with up to four arguments.
Alternatively, you can construct both fixed-size and dynamically-sized 
vector with data copied from a block of memory that you point them to:
\begin{verbatim}
  float *some_data;
  Vector<float> vector1(3, some_data);
  Vector<float,3> vector2(some_data);
\end{verbatim}
Remember that this copies the data, so it can be inefficient; see 
the discussion of \verb#VectorProxy# below for an alternative.
Three of the most commonly used vector types have special aliases, 
for convenience:
\begin{verbatim}
  typedef Vector<double,2> Vector2;
  typedef Vector<double,3> Vector3;
  typedef Vector<double,4> Vector4;
\end{verbatim}
These typese are used throughout the remainder of the Vision Workbench 
as the standard geometric vector types.

You can query a vector about its size (i.e. dimension or length) with
the \verb#size()# method, and you can index into a vector to access 
individual elements:
\begin{verbatim}
  for( unsigned i=0; i<vector1.size(); ++i ) vector1(i) = 0;
\end{verbatim}
This example loops over all the elements of a vector, setting them 
to zero.  You can also into a vector with square brackets instead 
of parentheses if you prefer.  For fixed-length vectors there is one 
more way to access up to the first three elements, via methods called 
\verb#x()#, \verb#y()#, and \verb#z()#.
\begin{verbatim}
  vector2.x() = 0;  // Set the first element to zero
\end{verbatim}
These methods are only available if the vector has sufficient 
length.  For example, attempting to use the \verb#z()# method of 
a vector of type \verb#Vector<float,2># will result in a compile-time 
error.  Remember, these methods are only available for fixed-size 
vectors, {\it not} dynamically-sized ones.  Dynamically-sized 
vectors, however, can be resized:
\begin{verbatim}
  vector1.set_size(10);
\end{verbatim}
The \verb#set_size()# function takes an optional second argument that 
specifies whether or not the vector contents should be preserved.  
This argument defaults to \verb#false#, so in the above example 
the old contents (if any) are lost.

\begin{table}[t!]\begin{centering}
\begin{tabular}{|c|l|} \hline
Function & Description \\ \hline \hline
\verb#- vector# & Vector negation \\ \hline
\verb#vector + vector# & Vector sum \\ \hline
\verb#vector - vector# & Vector difference \\ \hline
\verb#vector * scalar# & Scalar product \\ \hline
\verb#scalar * vector# & Scalar product \\ \hline
\verb#vector / scalar# & Scalar quotient \\ \hline
\verb#vector += vector# & Vector sum assignment \\ \hline
\verb#vector -= vector# & Vector difference assignment \\ \hline
\verb#vector *= scalar# & Scalar product assignment \\ \hline
\verb#vector /= scalar# & Scalar quotient assignment \\ \hline
\hline
\verb#elem_sum(vector,vector)# & Elementwise vector sum (same as \verb#+# operator) \\ \hline
\verb#elem_sum(vector,scalar)# & Elementwise sum of a vector and a scalar \\ \hline
\verb#elem_sum(scalar,vector)# & Elementwise sum of a scalar and a vector \\ \hline
\verb#elem_diff(vector,vector)# & Elementwise vector difference (same as \verb#-# operator) \\ \hline
\verb#elem_diff(vector,scalar)# & Elementwise difference of a vector and a scalar \\ \hline
\verb#elem_diff(scalar,vector)# & Elementwise difference of a scalar and a vector \\ \hline
\verb#elem_prod(vector,vector)# & Elementwise product of two vectors \\ \hline
\verb#elem_prod(vector,scalar)# & Elementwise vector product (same as \verb#*# operator) \\ \hline
\verb#elem_prod(scalar,vector)# & Elementwise vector product (same as \verb#*# operator) \\ \hline
\verb#elem_quot(vector,vector)# & Elementwise quotient of two vectors \\ \hline
\verb#elem_quot(vector,scalar)# & Elementwise quotient (same as \verb#/# operator) \\ \hline
\verb#elem_quot(scalar,vector)# & Elementwise quotient of a scalar and a vector \\ \hline
\hline
\verb#norm_1(vector)# & 1-norm of a vector, i.e. $\sum |v_i|$ \\ \hline
\verb#norm_2(vector)# & Euclidean 2-norm of a vector, i.e. $\sqrt{\sum v_i^2}$ \\ \hline
\verb#norm_2_sqr(vector)# & Squared 2-norm of a vector, i.e. $\sum v_i^2$ \\ \hline
\verb#norm_inf(vector)# & Infinity-norm of a vector, i.e. $\max |v_i|$ \\ \hline
\verb#sum(vector)# & Sum of elements, i.e. $\sum v_i$ \\ \hline
\verb#prod(vector)# & Product of elements, i.e. $\prod v_i$ \\ \hline
\verb#normalize(vector)# & The normalized form of a vector, i.e. $v/|v|$ \\ \hline
\verb#dot_prod(vector,vector)# & Vector dot product, i.e. $u\cdot v$ \\ \hline
\verb#cross_prod(vector,vector)# & Vector dot product, i.e. $u\times v$ \\ \hline
\end{tabular}
\caption{The vector math functions defined in {\tt <vw/Vector.h>}.}
\label{tbl:vector-functions}
\end{centering}\end{table}

The \verb#Vector# classes support the standard mathematical operations
of vector addition and subtraction and scalar multiplication and
division via the usual C++ operators.  They also support the a range
of elementwise mathematical operations, such as adding a scalar to
each element or multiplying the corresponding elements of two vectors,
via functions of the form \verb#elem_*#.  There are a number of vector
norms and related functions, as well as a vector dot product and cross
product.  (The cross product is, of course, only valid for
three-dimensional vectors.)  The complete list of vector math
functions defined in \verb#<vw/Vector.h># is given in
Table~\ref{tbl:vector-functions}.

A \verb#Vector# object is also a container in the C++ Standard Template 
Library sense of the word.  There is a \verb#Vector<...>::iterator# type 
that serves as the vector's iterator, and there are \verb#begin()# and 
\verb#end()# methods that return iterators to the first and one-past-the-last 
elements, as usual.  This can be an extremely convienient way to load 
data into and out of \verb#Vector#s.

You can extract a portion of a vector using the \verb#subvector()#
function, which takes three arguments: the original vector, the
position of the first element to extract, and the number of elements
in the resulting vector:
\begin{verbatim}
  Vector<float,3> vector2 = subvector(vector1,5,3);
\end{verbatim}
This example copies the fifth, sixth, and seventh elements of
\verb#vector1# into a new three-element vector.

The streaming operator \verb#<<# is also defined for writing vectors
to C++ output streams, which you can use to dump vector contents for
debugging:
\begin{verbatim}
  Vector<float,3> vector2(1,2,3);
  std::cout << vector2 << std::endl;
  // The output is: [3](1,2,3)
\end{verbatim}
Note that the size of the vector is printed first, followed by the 
vector's contents.

Sometimes it can be useful to work with data that is already stored in 
memory as though it were stored in a \verb#Vector# object.  As long as 
the data is stored in the usual packed format this is easy to do using 
the special \verb#VectorProxy# type, which also comes in fixed-size 
and dynamically-sized variants:
\begin{verbatim}
  float some_data[10] = {0,1,2,3,4,5,6,7,8,9};
  VectorProxy<float> proxy1(10, some_data);
  VectorProxy<float,10> proxy2(some_data);
\end{verbatim}
The constructor arguments are the same as are used in \verb#Vector# to
initialize a vector with data from a block of memory, except the data
is not copied.  You can now treat these proxy objects just like the
were regular \verb#Vector#s, except the contents will be stored in the
region of memory that you pointed them to.  In some situations this
can be considerably more efficient than copying the data
unnecessarily. (It is of course not possible to resize a
\verb#VectorProxy#, since the proxy does not have any control over the
memory that it is using.)

\subsection{Matrices and Matrix Operations}

The Vision workbench \verb#Matrix# class is the matrix 
counterpart to the \verb#Vector# class, and behaves quite 
similarly.  Once again, there are fixed-dimension and 
dynamically-sized versions:
\begin{verbatim}
  Matrix<float> matrix1(3,3);
  Matrix<float,3,3> matrix2;
\end{verbatim}
Note that the arguments to matrix-related functions such 
as these constructors are given in $i,j$ order, i.e. row 
followed by column.  This is {\it different} from images, 
where areguments are given in $x,y$ order, i.e. column 
followed by row.  You may find this confusing at first if 
you are moving to the Vision Workbench from an environment 
like Matlab where there is no distinction between images 
and matrices.  However, it is in keeping with the standard 
index ordering seen in the bulk of the image processsing 
and mathematics literatures, respectively.

You can initialize the matrix with data already stored 
in memory, as long as the data is stored in a packed 
row-major format:
\begin{verbatim}
  float some_data[4] = {1,2,3,4};
  Matrix<float> matrix1(2,2,some_data);
  Matrix<float,2,2> matrix2(some_data);
\end{verbatim}
As in the case of \verb#Vector#, the initialization data 
is {\it copied} into the matrix in this case, but there is 
also a proxy form that allows you treat in-memory data 
like an ordinary matrix:
\begin{verbatim}
  float some_data[4] = {1,2,3,4};
  MatrixProxy<float> matrix1(2,2,some_data);
  MatrixProxy<float,2,2> matrix2(some_data);
\end{verbatim}
The three most common matrix types have been given 
convenient aliases:
\begin{verbatim}
  typedef Matrix<double,2,2> Matrix2x2;
  typedef Matrix<double,3,3> Matrix3x3;
  typedef Matrix<double,4,4> Matrix4x4;
\end{verbatim}
These types are again the standard types used throughout the Vision 
Workbench in geometric applications.

You can query a matrix's dimensions using the \verb#rows()# and 
\verb#cols()# methods, and can index into the matrix to access 
individual elements.  There are two ways to do that:
\begin{verbatim}
  matrix(row,col) = 1;    // "New"-style indexing
  matrix[row][col] = 1;   // "Old"-style indexing
\end{verbatim}
A dynamically-sized matrix can be resized using the 
\verb#set_size()# method:
\begin{verbatim}
  matrix.set_size(rows,cols);
\end{verbatim}
As in the case of resizing vectors, the default behavior is that any
old data is not saved.  The \verb#set_size()# method takes an optional
third boolean parameter that can be set to \verb#true# to request that
it preserve the overlapping entries.

\begin{table}[t!]\begin{centering}
\begin{tabular}{|c|l|} \hline
Function & Description \\ \hline \hline
\verb#- matrix# & Matrix negation \\ \hline
\verb#matrix + matrix# & Matrix sum \\ \hline
\verb#matrix - matrix# & Matrix difference \\ \hline
\verb#matrix * scalar# & Scalar product \\ \hline
\verb#scalar * matrix# & Scalar product \\ \hline
\verb#matrix / scalar# & Scalar quotient \\ \hline
\verb#matrix += matrix# & Matrix sum assignment \\ \hline
\verb#matrix -= matrix# & Matrix difference assignment \\ \hline
\verb#matrix *= scalar# & Scalar product assignment \\ \hline
\verb#matrix /= scalar# & Scalar quotient assignment \\ \hline
\hline
\verb#matrix * matrix# & Matrix product \\ \hline
\verb#matrix * vector# & Matrix-vector product \\ \hline
\verb#vector * matrix# & Vector-matrix product \\ \hline
\hline
\verb#elem_sum(matrix,matrix)# & Elementwise matrix sum (same as \verb#+# operator) \\ \hline
\verb#elem_sum(matrix,scalar)# & Elementwise sum of a matrix and a scalar \\ \hline
\verb#elem_sum(scalar,matrix)# & Elementwise sum of a scalar and a matrix \\ \hline
\verb#elem_diff(matrix,matrix)# & Elementwise matrix difference (same as \verb#-# operator) \\ \hline
\verb#elem_diff(matrix,scalar)# & Elementwise difference of a matrix and a scalar \\ \hline
\verb#elem_diff(scalar,matrix)# & Elementwise difference of a scalar and a matrix \\ \hline
\verb#elem_prod(matrix,matrix)# & Elementwise product of two matrixs \\ \hline
\verb#elem_prod(matrix,scalar)# & Elementwise matrix product (same as \verb#*# operator) \\ \hline
\verb#elem_prod(scalar,matrix)# & Elementwise matrix product (same as \verb#*# operator) \\ \hline
\verb#elem_quot(matrix,matrix)# & Elementwise quotient of two matrixs \\ \hline
\verb#elem_quot(matrix,scalar)# & Elementwise quotient (same as \verb#/# operator) \\ \hline
\verb#elem_quot(scalar,matrix)# & Elementwise quotient of a scalar and a matrix \\ \hline
\hline
\verb#norm_1(matrix)# & Matrix 1-norm \\ \hline
\verb#norm_2(matrix)# & Matrix 2-norm \\ \hline
\verb#norm_frobenius(matrix)# & Matrix Frobenius norm \\ \hline
\verb#sum(matrix)# & Sum of elements, i.e. $\sum v_i$ \\ \hline
\verb#prod(matrix)# & Product of elements, i.e. $\prod v_i$ \\ \hline
\verb#trace(matrix)# & Matrix trace, i.e. $\sum M_{ii}$ \\ \hline
\verb#transpose(matrix)# & Matrix transpose, i.e. $M^T$ \\ \hline
\verb#inverse(matrix)# & Matrix inverse, i.e. $M^{-1}$ \\ \hline
\end{tabular}
\caption{The matrix math functions defined in {\tt <vw/Matrix.h>}.}
\label{tbl:matrix-functions}
\end{centering}\end{table}

Once you've made one or more matrices you can use a wide range of 
mathematical operator and functions to manipulate them.  The 
standard C++ operators, elementwise math functions, and a number 
of other functions similar to those for vectors are supported.  A 
list of the matrix math functions is given in Table~\ref{tbl:matrix-functions}.
Notice that some of these functions also operate with vectors: 
all vector functions that involve matrices are defined in 
\verb#<vw/Matrix.h># instead of \verb#<vw/Vector.h>#.

There is a special method, \verb#set_identity()#, that can be used 
to set a square matrix to the identity matrix of that size.
\begin{verbatim}
  Matrix<float> id(3,3);
  id.set_identity();
\end{verbatim}
If you want to treat a single row or column of a matrix as though 
it were a vector, you can do so using the \verb#select_row()# and 
\verb#select_col()# function:
\begin{verbatim}
  Vector<float> first_row = select_row(matrix,1);
  select_column(matrix,2) = Vector3(1,2,3);
\end{verbatim}
The second of these examples illustrates that you can use the 
\verb#select_*# functions to write into matrix rows and 
columns as well as read them out.  Finally, you can treat 
a block of a matrix as a smaller matrix in its own right 
using the \verb#submatrix()# function:
\begin{verbatim}
  Matrix<float> block = submatrix(matrix,row,col,rows,cols);
\end{verbatim}
You can also use this function to write into a region of a 
matrix, much as in the previous example using \verb#select_col()#.

Like \verb#Vector#, \verb#Matrix# is a C++ STL-compatible 
container class.  The \verb#Matrix<...>::iterator# iterates 
over the elements of a matrix in the same order that the 
\verb#ImageView#'s iterator does: across each row, moving 
down the matrix from each row to the next.  This is again a 
good method for loading or extracting matrix data from other 
containers.  To extract the matrix data to a stream for 
debugging output you can use the \verb#<<# stream output 
operator:
\begin{verbatim}
  double data[4] = {1,2,3,4};
  Matrix2x2 matrix(data);
  std::cout << matrix << std::endl;
  // The output is: [2,2]((1,2)(3,4))
\end{verbatim}
Again, the output includes the matrix dimensions (rows 
followed by cols), followed by the matrix data.

\section{Transforming or Warping Images}

\section{Where to Go from Here}
